{% load static %}
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>{{ title }}</title>

        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community/styles/ag-grid.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community/styles/ag-theme-alpine.css">

        <script src="https://cdn.jsdelivr.net/npm/ag-grid-community/dist/ag-grid-community.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@35.1.0/dist/ag-grid-enterprise.min.js"></script>
    </head>


    <body>
        {% include "home/alert_handler.html" %}
        {% include "home/side_bar.html" %}  

        <div class="main-content" style="margin-left: 15%;">
            <h1 class="text-center mt-4 mb-4"> RainFall Report </h1>
        </div>

        <div class="main-content" style="margin-left: 15%; padding: 2%; width: 85%; box-sizing: border-box;">
            <div id = "border_around_all_main_stuff" class = "p-4 border-2 border-gray-200 border-dashed rounded-lg dark:border-gray-700">

                <div class="row" id="first_display_row"> 

                    <div id="table_and_map_wrapper" style="display: flex; gap: 16px; align-items: stretch;">
                        <div id="table_Wrapper" style="height: 60vh; width: 60%;">
                            <div id="table" class="ag-theme-alpine" style="height: 100%; width: 100%;"></div>
                        </div>

                        <div id="map_Wrapper" style="height: 60vh; width: 40%;">
                            <div class="embed-map-fixed" style="position: relative; width: 100%; height: 100%;">
                                <div class="embed-map-container" style="overflow: hidden; background: none !important; width: 100%; height: 100%;">
                                    <iframe
                                        id="location-map-frame"
                                        class="embed-map-frame"
                                        frameborder="0"
                                        scrolling="no"
                                        marginheight="0"
                                        marginwidth="0"
                                        style="width: 100%; height: 100%;"
                                        src="https://maps.google.com/maps?width=600&height=400&hl=en&q={{ default_latitude }}%2C{{ default_longitude }}&t=&z=14&ie=UTF8&iwloc=B&output=embed"
                                    ></iframe>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="row" id="second_display_row"> 

                    <div id="plot_graph_wrapper" style="position: relative; width: 100%; height: 320px; margin-top: 16px;">
                        <canvas id="plot_graph" style="display: none; width: 100%; height: 100%;"></canvas>
                        <div id="plot_graph_loading" style="display: none; position: absolute; inset: 0; background: rgba(128, 128, 128, 0.45); color: #333; font-weight: 600; align-items: center; justify-content: center; text-align: center; z-index: 2;">
                            generating graph please wait
                        </div>
                    </div>

                </div>

            </div>




        </div>



        
    </body>


    {{ cell_data|json_script:"row-data" }}
    {{ columns|json_script:"columns-data" }}
    {{ latitude_and_longitude|json_script:"latitude-and-longitude-data" }}
    {{ ag_grid_enterprise_key|json_script:"ag-grid-enterprise-key" }}

    <script>

            const myGridElement = document.querySelector('#table');
            const mapFrameElement = document.getElementById('location-map-frame');
            const plotGraphCanvas = document.getElementById('plot_graph');
            const plotGraphLoadingElement = document.getElementById('plot_graph_loading');

            const fullRowData = JSON.parse(document.getElementById('row-data').textContent);
            const agGridEnterpriseKeyElement = document.getElementById('ag-grid-enterprise-key');
            const agGridEnterpriseKey = agGridEnterpriseKeyElement
                ? JSON.parse(agGridEnterpriseKeyElement.textContent)
                : '';

            if (agGridEnterpriseKey && window.agGrid && agGrid.LicenseManager) {
                agGrid.LicenseManager.setLicenseKey(agGridEnterpriseKey);
            }

            const INITIAL_ROW_COUNT = 500;
            const initialRowData = Array.isArray(fullRowData) ? fullRowData.slice(0, INITIAL_ROW_COUNT) : [];
            const remainingRowData = Array.isArray(fullRowData) ? fullRowData.slice(INITIAL_ROW_COUNT) : [];
            const columns = JSON.parse(document.getElementById('columns-data').textContent);
            let rainfallChart = null;
            const latitudeAndLongitudeElement = document.getElementById('latitude-and-longitude-data');
            const latitudeAndLongitude = latitudeAndLongitudeElement
                ? JSON.parse(latitudeAndLongitudeElement.textContent)
                : {};
            const locationLookup = Object.entries(latitudeAndLongitude).reduce((accumulator, [key, value]) => {
                accumulator[key.toLowerCase()] = value;
                return accumulator;
            }, {});
            const columnDefs = columns.map((column) => {
                const isLocationColumn = column.toLowerCase() === 'location';
                const isRainfallColumn = column.toLowerCase() === 'rainfall';
                if (isLocationColumn) {
                    return {
                        field: column,
                        filter: 'agSetColumnFilter',
                        cellStyle: { color: '#0d6efd', textDecoration: 'underline', cursor: 'pointer' }
                    };
                }

                if (isRainfallColumn) {
                    return {
                        field: column,
                        maxWidth: 192
                    };
                }

                return { field: column };
            });

            console.log("latitude_and_longitude", latitudeAndLongitude);

            function setGraphLoading(isLoading) {
                if (!plotGraphLoadingElement) {
                    return;
                }

                if (isLoading) {
                    plotGraphLoadingElement.style.display = 'flex';
                    if (plotGraphCanvas) {
                        plotGraphCanvas.style.display = 'block';
                    }
                } else {
                    plotGraphLoadingElement.style.display = 'none';
                }
            }

            function renderRainfallChart(rowsToPlot) {
                if (!rowsToPlot) {
                    rowsToPlot = [];
                    if (gridApi && typeof gridApi.forEachNodeAfterFilterAndSort === 'function') {
                        gridApi.forEachNodeAfterFilterAndSort((node) => {
                            if (node.data) rowsToPlot.push(node.data);
                        });
                    }
                }
                if (!plotGraphCanvas || typeof Chart === 'undefined') {
                    return;
                }

                const timeColumn = columns.find((column) => column.toLowerCase() === 'time');
                const rainfallColumn = columns.find((column) => column.toLowerCase() === 'rainfall');
                const locationColumn = columns.find((column) => column.toLowerCase() === 'location');

                if (!timeColumn || !rainfallColumn || !locationColumn) {
                    return;
                }

                const allTimes = new Set();
                const groupedByLocation = {};

                for (const row of rowsToPlot) {
                    const location = row[locationColumn];
                    const time = row[timeColumn];
                    const rainfallValue = Number(row[rainfallColumn]);

                    if (!location || !time || Number.isNaN(rainfallValue)) {
                        continue;
                    }

                    allTimes.add(time);
                    if (!groupedByLocation[location]) {
                        groupedByLocation[location] = {};
                    }

                    groupedByLocation[location][time] = rainfallValue;
                }

                const labels = Array.from(allTimes).sort();
                const datasets = Object.entries(groupedByLocation).map(([location, rainfallByTime]) => ({
                    label: location,
                    data: labels.map((time) => (time in rainfallByTime ? rainfallByTime[time] : null)),
                    borderWidth: 2,
                    tension: 0.2,
                    spanGaps: true
                }));

                if (rainfallChart) {
                    rainfallChart.destroy();
                    rainfallChart = null;
                }

                if (!labels.length || !datasets.length) {
                    plotGraphCanvas.style.display = 'none';
                    return;
                }

                plotGraphCanvas.style.display = 'block';

                rainfallChart = new Chart(plotGraphCanvas, {
                    type: 'line',
                    data: {
                        labels,
                        datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Time'
                                },
                                ticks: {
                                    autoSkip: true,
                                    maxTicksLimit: 12,
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Rainfall'
                                }
                            }
                        }
                    }
                });
            }

            function updateMapToCoordinates(latitude, longitude) {
                if (!mapFrameElement) {
                    return;
                }

                mapFrameElement.src = `https://maps.google.com/maps?width=600&height=400&hl=en&q=${encodeURIComponent(`${latitude},${longitude}`)}&t=&z=14&ie=UTF8&iwloc=B&output=embed`;
            }

            function moveMapToLocation(locationValue) {
                if (!locationValue) {
                    return;
                }

                const coordinates = latitudeAndLongitude[locationValue] || locationLookup[String(locationValue).toLowerCase()];
                if (!coordinates || coordinates.length < 2) {
                    return;
                }

                updateMapToCoordinates(coordinates[0], coordinates[1]);
            }



            const defaultColDef = {
                flex: 1,
                filter: true,
                editable: true,
            };

            const gridOptions = {
                // Row Data: show initial rows first for faster initial render.
                rowData: initialRowData,
                // Column Definitions: Defines the columns to be displayed.
                columnDefs,
                defaultColDef,
                onFilterChanged: (params) => {
                    const filteredRows = [];
                    params.api.forEachNodeAfterFilterAndSort((node) => {
                        if (node.data) {
                            filteredRows.push(node.data);
                        }
                    });

                    renderRainfallChart(filteredRows);
                },
                onCellClicked: (params) => {
                    if (!params.colDef?.field || params.colDef.field.toLowerCase() !== 'location') {
                        return;
                    }

                    moveMapToLocation(params.value);
                }
            };

            const gridApi = agGrid.createGrid(myGridElement, gridOptions);

            // render chart from what is currently in the grid (initial rows)
            const initialRows = [];
            gridApi.forEachNodeAfterFilterAndSort((node) => {
                if (node.data) {
                    initialRows.push(node.data);
                }
            });
            renderRainfallChart(initialRows);

            // Append remaining rows in small chunks to avoid blocking the UI.
            function appendRowsInChunks(rows, chunkSize = 1000) {
                if (!rows || !rows.length) return;
                let i = 0;
                function next() {
                    const chunk = rows.slice(i, i + chunkSize);
                    if (chunk.length) {
                        gridApi.applyTransaction({ add: chunk });
                        i += chunk.length;
                        // schedule next chunk asynchronously
                        setTimeout(next, 0);
                    } else {
                        // update chart with all rows now in the grid
                        const allRows = [];
                        gridApi.forEachNodeAfterFilterAndSort((node) => {
                            if (node.data) allRows.push(node.data);
                        });
                        renderRainfallChart(allRows);
                        setGraphLoading(false);
                    }
                }
                // start appending immediately but asynchronously
                setTimeout(next, 0);
            }

            setGraphLoading(remainingRowData.length > 0);

            // Kick off background append for the remaining rows
            appendRowsInChunks(remainingRowData, 1000);

    </script>

</html>